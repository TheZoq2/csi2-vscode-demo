use protocols::i2c::i2c_controller;
use protocols::i2c::I2CConfig;
use protocols::i2c::Command as I2CCommand;


use std::mem::clocked_memory_init;
use std::ports::new_mut_wire;
use std::ports::read_mut_wire;

use lib::uart_config::Command;

// The type parameter here is a giant hack. We won't specify it at the call site,
// instead we'll force it to infer it to be the length of the configuration.
entity configurator<#N>(
    clk: clock,
    rst: bool,
    i2c_config: I2CConfig,

    sclk: &mut bool,
    sda_drive_low: &mut bool,
    sda_in: bool,

    command: Option<Command>,

    reinit_unsync: bool,
) {
    let reinit = inst std::io::rising_edge(clk, inst std::cdc::sync2_bool(clk, reinit_unsync));

    let framelength: uint<16> = 1120;
    let linelength: uint<16> = 3448;
    let pixel_width: uint<16> = 1024;
    let pixel_height: uint<16> = 600;
    let coarse_integ_time: uint<16> = 32;
    let fine_integ_time: uint<16> = 250;

    // let binning = 2;
    // let bin_config = match binning {
    //     1 => 0,
    //     2 => 1,
    //     4 => 2,
    //     // other => panic!("Invalid binning")
    // };
    let bin_config = 1;
    let pll_offset: uint<16> = 16;

    // NOTE: For now, there is a bug where if the length of this array changes,
    // there will be a type error which is very hard to decipher here. The fix is to
    // set N in the turbofish at the instantiation site
    let configuration: [(uint<16>, uint<8>); N] =
        [
            // Based on "Preview Setting" from a Linux driver
            (0x0100, 0x00), //standby mode
            (0x30EB, 0x05), //mfg specific access begin
            (0x30EB, 0x0C), //
            (0x300A, 0xFF), //
            (0x300B, 0xFF), //
            (0x30EB, 0x05), //
            (0x30EB, 0x09), //mfg specific access end
            (0x0114, 0x01), //CSI_LANE_MODE: 2-lane
            (0x0128, 0x00), //DPHY_CTRL: auto mode (?)
            (0x012A, 0x18), //EXCK_FREQ[15:8] = 24MHz
            (0x012B, 0x00), //EXCK_FREQ[7:0]
            (0x0160, trunc(framelength >> 8)), //framelength
            (0x0161, trunc(framelength)),
            (0x0162, trunc(linelength >> 8)),
            (0x0163, trunc(linelength)),
            (0x0164, 0x00), //X_ADD_STA_A[11:8]
            (0x0165, 0x00), //X_ADD_STA_A[7:0]
            (0x0166, trunc((pixel_width << bin_config) >> 8)), // X_ADD_END_A
            (0x0167, trunc(pixel_width << bin_config)), // X_ADD_END_A
            (0x0168, 0x00), //Y_ADD_STA_A[11:8]
            (0x0169, 0x00), //Y_ADD_STA_A[7:0]
            (0x016A, trunc((pixel_height << bin_config) >> 8)), //Y_ADD_END_A[11:8]
            (0x016B, trunc(pixel_height << bin_config)), //Y_ADD_END_A[11:8]
            (0x016C, trunc(pixel_width >> 8)), //x_output_size[11:8] = 640
            (0x016D, trunc(pixel_width)), //x_output_size[7:0]
            (0x016E, trunc(pixel_height >> 8)), //y_output_size[11:8] = 480
            (0x016F, trunc(pixel_height)), //y_output_size[7:0]
            (0x0170, 0x01), //X_ODD_INC_A
            (0x0171, 0x01), //Y_ODD_INC_A
            (0x0172, 0b00), //Image orientation (flip both)
            (0x0174, trunc(bin_config)), //BINNING_MODE_H_A = x4-binning
            (0x0175, trunc(bin_config)), //BINNING_MODE_V_A = x4-binning
            (0x018C, 0x08), //CSI_DATA_FORMAT_A[15:8]
            (0x018D, 0x08), //CSI_DATA_FORMAT_A[7:0]
            (0x0301, 0x08), //VTPXCK_DIV
            (0x0303, 0x01), //VTSYCK_DIV
            (0x0304, 0x02), //PREPLLCK_VT_DIV
            (0x0305, 0x02), //PREPLLCK_OP_DIV
            // write_cmos_sensor_u16(&mut i2c, 0x0306, 0x0014 + pll_offset); //PLL_VT_MPY[10:8]
            (0x0306, trunc((0x0014 + pll_offset) >> 8)),
            (0x0307, trunc((0x0014 + pll_offset))),
            (0x0309, 0x08), //OPPXCK_DIV
            (0x030B, 0x02), //OPSYCK_DIV
            (0x030C, trunc((0x000A + pll_offset) >> 8)), //PLL_OP_MPY[10:8]
            (0x030D, trunc((0x000A + pll_offset))), //PLL_OP_MPY[10:8]
            (0x455E, 0x00), //??
            (0x471E, 0x4B), //??
            (0x4767, 0x0F), //??
            (0x4750, 0x14), //??
            (0x4540, 0x00), //??
            (0x47B4, 0x14), //??
            (0x4713, 0x30), //??
            (0x478B, 0x10), //??
            (0x478F, 0x10), //??
            (0x4793, 0x10), //??
            (0x4797, 0x0E), //??
            (0x479B, 0x0E), //??

            (0x189A, trunc(coarse_integ_time >> 8)), // COARSE_INTEG_TIME_SHORT_A
            (0x189B, trunc(coarse_integ_time)), // COARSE_INTEG_TIME_SHORT_A
            (0x0389, trunc(fine_integ_time >> 8)), // FINE_INTEG_TIME
            (0x0389, trunc(fine_integ_time)), // FINE_INTEG_TIME


            (0x0157,  120), // ANA_GAIN_GLOBAL_A
            (0x0257,  120), // ANA_GAIN_GLOBAL_B

            (0x0600,  0x00), // Test pattern: disable
            (0x0601,  0x00), // Test pattern: disable

            (0x0100, 0x01)
        ];

    let ready = inst new_mut_wire();

    reg(clk) next_config reset(rst: 0) =
        if reinit {0} else {
            if next_config == N {
                next_config
            } else {
                if inst read_mut_wire(ready) {
                    trunc(next_config + 1)
                } else {
                    next_config
                }
            }
        };

    let command = if next_config == N {
        match command {
            Some(Command$(target: 0, payload)) => {
                let addr = payload[0] `concat` payload[1];
                let byte = payload[2];
                Some(I2CCommand::Write(0x10, addr, byte))
            },
            _ => None,
        }
    } else {
        let (addr, byte) = configuration[next_config];
        Some(I2CCommand::Write(0x10, addr, byte))
    };

    let _ = inst i2c_controller$(clk, rst, cfg: i2c_config, ready, command, sclk, sda_drive_low, sda_in);
}

