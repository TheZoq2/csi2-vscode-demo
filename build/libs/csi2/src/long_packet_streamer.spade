enum DecoderState {
    WaitPacket,
    WaitWordCount{id: uint<8>, count: uint<16>, remain_mask: uint<2>},
    WaitEcc{id: uint<8>, count: uint<16>},
    WaitData{id: uint<8>, remain: uint<16>},
    WaitEnd{remain_mask: uint<2>}
}

struct LongStreamData {
    id: uint<8>,
    data: uint<8>,
}

struct LongStream {
    data: Option<LongStreamData>
}

impl LongStream {
    fn filter_raw_pixels(self) -> Option<uint<8>> {
        match self.data {
            Some(LongStreamData$(id, data)) => if (id & 0b0011_1111) == 0x2A {
                Some(data)
            } else {
                None()
            },
            None => None()
        }
    }
}

entity long_packet_streamer(sys_clk: clock, rst: bool, aligned: Option<uint<8>>) -> LongStream {
    let now_aligned = match aligned {Some(_) => true, None => false};
    reg(sys_clk) prev_aligned = now_aligned;
    let just_aligned = now_aligned && !prev_aligned;

    reg(sys_clk) state reset(rst: DecoderState::WaitPacket()) = {
        match aligned {
            Some(byte) => {
                match state {
                    DecoderState::WaitPacket => {
                        if just_aligned {
                            if (byte & 0b0011_1111) == 0x2A {
                                DecoderState::WaitWordCount$(id: byte, count: 0, remain_mask: 0b11)
                            } else {
                                DecoderState::WaitPacket()
                            }
                        }
                        else {
                            state
                        }
                    },
                    DecoderState::WaitWordCount$(id, count, remain_mask) => {
                        let new_count = (count << 8) + zext(byte);
                        let new_mask = remain_mask >> 1;

                        if new_mask == 0 {
                            DecoderState::WaitEcc$(id, count: trunc(new_count))
                        }
                        else {
                            DecoderState::WaitWordCount$(
                                id,
                                count: trunc(new_count),
                                remain_mask: remain_mask << 1
                            )
                        }
                    },
                    DecoderState::WaitEcc$(id, count) => {
                        DecoderState::WaitData$(id, remain: count)
                    },
                    DecoderState::WaitData$(id, remain: 1) => DecoderState::WaitEnd(0b11),
                    DecoderState::WaitData$(id, remain) => DecoderState::WaitData$(
                        id,
                        remain: trunc(remain - 1)
                    ),
                    DecoderState::WaitEnd(remain_mask) => {
                        if remain_mask == 1 {
                            DecoderState::WaitPacket()
                        }
                        else {
                            DecoderState::WaitEnd(remain_mask >> 1)
                        }
                    }
                }
            },
            None => DecoderState::WaitPacket(),
        }
    };

    // Spec section 9.8
    match state {
        DecoderState::WaitData$(id, remain: _) => {
            match aligned {
                Some(byte) => LongStream(Some(LongStreamData$(id, data: byte))),
                None => LongStream(None())
            }
        },
        _ => LongStream(None())
    }
}
