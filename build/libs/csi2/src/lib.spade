use std::ports::new_mut_wire;
use std::ports::read_mut_wire;

use lib::short_packet::ShortPacketStream;
use lib::lane_merger::lane_merger;
use lib::alignment::lane_aligner;
use lib::header_decoding::PixelStream;

struct Csi2Debug {
    align0: bool,
    align1: bool,
    ecc_corrected: bool,
    ecc_error: bool,
}

struct FrontendOut {
    short_packets: ShortPacketStream,
    pixels: PixelStream
}

pipeline(7) csi2_frontend(
    sys_clk: clock,
    rst: bool,
    dphy_lp: bool,
    unaligned_bytes: [uint<8>; 2],
    dbg: &mut Csi2Debug
) -> FrontendOut {
    reg * 2; // Domain crossing into the sysclk domain
        let aligned = inst lane_aligner$(
            sys_clk,
            rst,
            dphy_lp,
            lanes: unaligned_bytes
        );
    reg;
        let merged = lane_merger(aligned);
    reg;
        let ecc_corrected = inst new_mut_wire();
        let ecc_error = inst new_mut_wire();
        let headers = merged
            .inst into_packet_headers$(sys_clk, rst, ecc_corrected, ecc_error);
    reg;
        let short_packets = headers
            .into_short_packets();
        let pixel_headers = headers
            .only_id(0x2A);
    reg;
        let raw_pixels = pixel_headers
            .inst into_pixel_stream(sys_clk, rst, merged);
    reg;
        set dbg = Csi2Debug$(
            align0: match aligned#0 { Some(_) => true, None => false, },
            align1: match aligned#1 { Some(_) => true, None => false, },
            ecc_corrected: inst read_mut_wire(ecc_corrected),
            ecc_error: inst read_mut_wire(ecc_error),
        );

        FrontendOut(short_packets, raw_pixels)
}

#[no_mangle]
entity csi2_frontend_th(
    sys_clk: clock,
    rst: bool,
    dphy_lp: bool,
    unaligned_bytes: [uint<8>; 2],
) -> FrontendOut {
    inst (7) csi2_frontend$(sys_clk, rst, dphy_lp, unaligned_bytes, dbg: inst new_mut_wire())
}
