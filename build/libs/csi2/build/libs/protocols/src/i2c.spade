use std::ports::new_mut_wire;
use std::ports::read_mut_wire;

// Uses the controller/target naming scheme used by i2c after v7 of the spec.
// What used to be master/slave is now controller/target

struct I2CConfig {
    clk_period: uint<20>
}

enum Response {
    // Write ack
    Ack,
    // Write or read nack
    Nack,
    // Read ack with data
    Data{val: uint<8>}
}

enum Command {
    Write{device: uint<7>, addr: uint<16>, byte: uint<8>},
    Read{device: uint<7>, addr: uint<16>},
}
impl Command {
    fn into_bytes(self) -> ByteQueue {
        match self {
            Command::Write$(device, addr, byte) => new_byte_queue([device `concat` 0, trunc(addr >> 8), trunc(addr), byte], 4),
            Command::Read$(device, addr) => new_byte_queue([device `concat` 1, trunc(addr >> 8), trunc(addr), 0], 3)
        }
    }

    fn is_write(self) -> bool {
        match self {
            Command::Write(_, _, _) => true,
            Command::Read(_, _) => false
        }
    }
}

struct ByteQueue {
    inner: [uint<8>; 4],
    count: uint<3>,
    idx: uint<3>
}

fn new_byte_queue(inner: [uint<8>; 4], count: uint<3>) -> ByteQueue {
    ByteQueue $(
        inner,
        count,
        idx: 0
    )
}

impl ByteQueue {
    fn is_empty(self) -> bool {
        self.idx == self.count
    }

    fn next(self) -> ByteQueue {
        ByteQueue $(
            inner: self.inner,
            count: self.count,
            idx: trunc(self.idx + 1)
        )
    }

    fn byte(self) -> uint<8> {
        self.inner[trunc(self.idx)]
    }
}

enum ControllerState {
    Idle,
    StartBit{bytes: ByteQueue, duration_left: uint<20>, write: bool},
    Transact{bytes: ByteQueue, write: bool},
    StopBit{duration_left: uint<20>}
}
use ControllerState as CState;

// NOTE: Does not support clock stretching by targets
entity i2c_controller(
    clk: clock,
    rst: bool,
    cfg: I2CConfig,
    command: Option<Command>,
    ready: &mut bool,
    #[no_mangle]
    sclk: &mut bool,
    #[no_mangle]
    sda_drive_low: &mut bool,
    // Since we don't have support for bidirectional ports yet, we'll have a separate
    // input port which we can read from. In the pin assignment, both sda and sda_in
    // should be mapped to the same pin
    #[no_mangle]
    sda_in: bool,
) -> Option<Response> {
    let emitter_ready = inst new_mut_wire();

    reg(clk) state reset(rst: ControllerState::Idle()) = {
        match state {
            ControllerState::Idle => {
                match (command, inst read_mut_wire(emitter_ready)) {
                    (Some(command), true) => {
                        ControllerState::StartBit $(
                            bytes: command.into_bytes(),
                            duration_left: cfg.clk_period,
                            write: command.is_write(),
                        )
                    },
                    _ => state,
                }
            },
            ControllerState::StartBit$(bytes, duration_left, write) => {
                if duration_left == 1 {
                    ControllerState::Transact$(bytes, write)
                } else {
                    ControllerState::StartBit$(bytes, duration_left: trunc(duration_left - 1), write)
                }
            },
            ControllerState::Transact$(bytes, write) => {
                if inst read_mut_wire(emitter_ready) {
                    if bytes.is_empty() {
                        ControllerState::StopBit(cfg.clk_period)
                    } else {
                        ControllerState::Transact$(bytes: bytes.next(), write)
                    }
                }
                else {
                    state
                }
            },
            ControllerState::StopBit(duration_left) => {
                if duration_left == 1 {
                    ControllerState::Idle()
                } else {
                    ControllerState::StopBit(trunc(duration_left - 1))
                }
            }
        }
    };

    set ready = match (state, inst read_mut_wire(emitter_ready)) {
        (ControllerState::Idle, true) => true,
        _ => false,
    };

    let byte_to_emit = match state {
        ControllerState::Transact(bytes, _) => Some(bytes.byte()),
        _ => None()
    };

    // TODO: Refactor to not pass these as wires
    let emitter_sda_drive_low = inst new_mut_wire();
    let emitter_sclk = inst new_mut_wire();

    let ack_nack = inst byte_emitter$(
        clk,
        rst,
        cfg,
        byte: byte_to_emit,
        sclk: emitter_sclk,
        sda_drive_low: emitter_sda_drive_low,
        ready: emitter_ready,
        sda_in
    );

    set sda_drive_low = match state {
        ControllerState::Idle => false,
        ControllerState::StartBit(_, _, _) => true,
        ControllerState::Transact(_, _) => inst read_mut_wire(emitter_sda_drive_low),
        ControllerState::StopBit(duration) => if duration > (cfg.clk_period >> 2) {
            true
        }
        else {
            false
        },
    };
    set sclk = match state {
        ControllerState::Idle => true,
        ControllerState::StartBit(_, _, _) => true,
        ControllerState::Transact(_, _) => inst read_mut_wire(emitter_sclk),
        ControllerState::StopBit(duration) => if duration > (cfg.clk_period >> 1) {
            false
        }
        else {
            true
        },
    };



    match ack_nack {
        Some(AckNack::Ack) => {
            Some(Response::Ack())
        },
        Some(AckNack::Nack) => {
            Some(Response::Nack())
        },
        None => None ()
    }
}

enum ByteEmitterState {
    Idle,
    Transmit{bits: uint<8>, mask: uint<8>},
    Ack{duration: uint<20>},
}

enum AckNack {
    Ack,
    Nack,
}

entity byte_emitter(
    clk: clock,
    rst: bool,
    cfg: I2CConfig,
    byte: Option<uint<8>>,
    #[no_mangle]
    sclk: &mut bool,
    #[no_mangle]
    sda_drive_low: &mut bool,
    #[no_mangle]
    sda_in: bool,
    #[no_mangle]
    ready: &mut bool
) -> Option<AckNack> {
    decl sclk_driver_out;

    reg(clk) state reset (rst: ByteEmitterState::Idle()) =
        match state {
            ByteEmitterState::Idle => {
                match byte {
                    Some(bits) => ByteEmitterState::Transmit$(bits, mask: 0xff),
                    None => ByteEmitterState::Idle(),
                }
            },
            ByteEmitterState::Transmit$(bits, mask) => {
                if sclk_driver_out.falling {
                    if mask == 0b1000_0000 {
                        ByteEmitterState::Ack(cfg.clk_period)
                    }
                    else {
                        ByteEmitterState::Transmit$(bits: bits<<1, mask: mask<<1)
                    }
                }
                else {
                    state
                }
            },
            ByteEmitterState::Ack(duration) => {
                if duration == 1 {
                    match byte {
                        Some(bits) => ByteEmitterState::Transmit$(bits, mask: 0xff),
                        None => ByteEmitterState::Idle(),
                    }
                } else {
                    ByteEmitterState::Ack(trunc(duration - 1))
                }
            }
        };

    let num_cycles = match (state, byte) {
        (ByteEmitterState::Idle, Some(_)) => Some(9),
        (ByteEmitterState::Ack(1), Some(_)) => Some(9),
        _ => None(),
    };

    let sclk_driver_out = inst sclk_driver(clk, rst, cfg, num_cycles);
    set sclk = sclk_driver_out.sclk;

    set sda_drive_low = match state {
        ByteEmitterState::Transmit$(bits, mask: _) => {
            if (bits & 0b1000_0000) != 0 {
                false
            } else {
                true
            }
        },
        _ => false
    };
    set ready = match state {
        ByteEmitterState::Idle => true,
        ByteEmitterState::Ack(1) => true,
        _ => false
    };

    match (state, sclk_driver_out.rising) {
        (ByteEmitterState::Ack(_), true)  => {
            if !sda_in {
                Some(AckNack::Ack())
            } else {
                Some(AckNack::Nack())
            }
        },
        _ => None()
    }
}


enum SclkDriverState {
    Idle,
    Run{cycles_left: uint<8>, duration: uint<20>},
}

struct SclkDriverOut {
    sclk: bool,
    falling: bool,
    rising: bool
}

// Drives the clock for num_cycles
entity sclk_driver(clk: clock, rst: bool, cfg: I2CConfig, num_cycles: Option<uint<8>>) -> SclkDriverOut {
    reg(clk) state reset(rst: SclkDriverState::Idle()) = match (state, num_cycles) {
        (SclkDriverState::Idle, Some(cycles)) => SclkDriverState::Run$(
            cycles_left: cycles,
            duration: cfg.clk_period
        ),
        (SclkDriverState::Idle, None) => SclkDriverState::Idle(),
        (SclkDriverState::Run$(cycles_left: 1, duration: 1), Some(cycles)) => SclkDriverState::Run$(
            cycles_left: cycles,
            duration: cfg.clk_period
        ),
        (SclkDriverState::Run$(cycles_left: 1, duration: 1), _) => SclkDriverState::Idle(),
        (SclkDriverState::Run$(cycles_left, duration: 1), _) => SclkDriverState::Run$(
            cycles_left: trunc(cycles_left - 1),
            duration: cfg.clk_period
        ),
        (SclkDriverState::Run$(cycles_left, duration), _) => SclkDriverState::Run$(
            cycles_left,
            duration: trunc(duration - 1)
        )
    };

    let sclk = match state {
        SclkDriverState::Idle => true,
        SclkDriverState::Run$(cycles_left: _, duration) => (duration << 1) <= cfg.clk_period
    };
    let rising = match state {
        SclkDriverState::Run$(cycles_left: _, duration) => (duration << 1) == cfg.clk_period,
        _ => false
    };
    let falling = match state {
        SclkDriverState::Run$(cycles_left: _, duration) => duration == 1,
        _ => false
    };
    SclkDriverOut$(sclk, falling, rising)
}
 
