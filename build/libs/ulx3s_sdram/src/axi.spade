use std::ports::read_mut_wire;
use std::ports::new_mut_wire;

enum AxiBurst {
    Fixed,
    Incr,
    Wrap
}

struct port AxiAw<#IdWidth> {
    valid: &mut bool,
    ready: &bool,
    addr: &mut int<25>,
    burst: &mut AxiBurst,
    len: &mut int<8>,
    size: &mut int<3>,
    id: &mut int<IdWidth>
}

struct port AxiW {
    valid: &mut bool,
    ready: &bool,
    last: &mut bool,
    strb: &mut int<2>,
    data: &mut int<16>,
}

struct port AxiB<#IdWidth> {
    valid: &bool,
    ready: &mut bool,
    resp: &int<2>,
    id: &int<IdWidth>
}

struct port AxiAr<#IdWidth> {
    valid: &mut bool,
    ready: &bool,
    addr: &mut int<25>,
    burst: &mut AxiBurst,
    len: &mut int<8>,
    size: &mut int<3>,
    id: &mut int<IdWidth>
}

struct port AxiR<#IdWidth> {
    valid: &bool,
    ready: &mut bool,
    last: &bool,
    resp: &int<2>,
    data: &int<16>,
    id: &int<8>,
}

struct port AxiPort<#IdWidth> {
    aw: AxiAw<IdWidth>,
    w: AxiW,
    b: AxiB<IdWidth>,
    ar: AxiAr<IdWidth>,
    r: AxiR<IdWidth>
}

// NOTE: Turn this into a port once we support impl on generics
entity axi_unused<#IdWidth>(p: AxiPort<IdWidth>) -> bool {
    let _ = inst axi_w_unused(p.aw, p.w, p.b);

    let ar = p.ar;
    set ar.valid = false;
    set ar.id = 0;
    set ar.addr = 0;
    set ar.burst = AxiBurst::Fixed();
    set ar.len = 0;
    set ar.size = 0;

    set p.r.ready = false;
    true
}

entity axi_w_unused<#IdWidth>(aw: AxiAw<IdWidth>, w: AxiW, b: AxiB<IdWidth>) -> bool {
    set aw.valid = false;
    set aw.id = 0;
    set aw.addr = 0;
    set aw.burst = AxiBurst::Fixed();
    set aw.len = 0;
    set aw.size = 0;

    set w.valid = false;
    set w.last = false;
    set w.strb = 0;
    set w.data = 0;

    set b.ready = false;

    false
}

struct port Rv<T> {
    payload: &Option<T>,
    ready: &mut bool,
}

enum SingleReadState {
    // Waiting for an address to read from
    WaitAddr,
    // Waiting for a ready signal from the AR subordinate
    WaitReady{addr: int<25>},
    /// Waiting for a valid signal from the R subordinate
    WaitRValid,
}

// NOTE: Turn this into a port once we support impl on generics
entity axi_single_read<#IdWidth>(
    clk: clock,
    rst: bool,
    p: AxiPort<IdWidth>,
    addr: Rv<int<25>>
) -> Option<int<16>> {
    let _ = inst axi_w_unused(p.aw, p.w, p.b);
    let ar = p.ar;
    let r = p.r;

    reg(clk) state reset(rst: SingleReadState::WaitAddr()) = match state {
        SingleReadState::WaitAddr => {
            match *addr.payload {
                Some(addr) => SingleReadState::WaitReady(addr),
                None => state
            }
        },
        SingleReadState::WaitReady(addr) => {
            if *ar.ready {
                SingleReadState::WaitRValid()
            }
            else {
                state
            }
        },
        SingleReadState::WaitRValid => {
            if *r.valid {
                SingleReadState::WaitAddr()
            }
            else {
                state
            }
        }
    };

    // Communicate the ready signa lback to the rv interface
    set addr.ready = match state {
        SingleReadState::WaitAddr => true,
        _ => false
    };

    // Actual AXI signals
    set r.ready = match state {
        SingleReadState::WaitRValid => true,
        _ => false
    };
    set ar.valid = match state {
        SingleReadState::WaitReady(_) => true,
        _ => false
    };
    set ar.size = 1;
    set ar.addr = match state {
        SingleReadState::WaitReady(addr) => addr,
        _ => 0
    };
    set ar.burst = AxiBurst::Fixed();
    set ar.len = 1;
    set ar.id = 0;

    match (state, *r.valid) {
        (SingleReadState::WaitRValid, true) => Some(*r.data),
        _ => None()
    }
}

struct port AxiPins<#IdWidth> {
    awvalid: &bool,
    awready: &mut bool,
    awaddr: &int<25>,
    awburst: &int<2>,
    awlen: &int<8>,
    awsize: &int<3>,
    awid: &int<IdWidth>,
    wvalid: &bool,
    wready: &mut bool,
    wlast: &bool,
    wstrb: &int<2>,
    wdata: &int<16>,
    bvalid: &mut bool,
    bready: &bool,
    bresp: &mut int<2>,
    bid: &mut int<IdWidth>,
    arvalid: &bool,
    arready: &mut bool,
    araddr: &int<25>,
    arburst: &int<2>,
    arlen: &int<8>,
    arsize: &int<3>,
    arid: &int<IdWidth>,
    rvalid: &mut bool,
    rready: &bool,
    rlast: &mut bool,
    rresp: &mut int<2>,
    rdata: &mut int<16>,
    rid: &mut int<IdWidth>,
}

