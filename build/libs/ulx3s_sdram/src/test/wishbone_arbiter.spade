use lib::main::DramWishbone;

use std::mem::clocked_memory;
use std::mem::read_memory;
use std::ports::read_mut_wire;

enum State {
    Idle{priority: uint<1>},
    Service1{delay: int<8>},
    Service2{delay: int<8>}
}

// A fake wishbone memory which can only service one wishbone port at a time
// and will reply to its request after the specified delay (which can vary
// dynamically)
// This allocates a large amount of memory, so it is likely not synthesizeable
entity wishbone_arbiter(
    clk: clock,
    rst: bool,
    port1: ~DramWishbone,
    port2: ~DramWishbone,
    delay1: int<8>,
    delay2: int<8>
) -> bool {
    #[fsm]
    reg(clk) state reset (rst: State::Idle(0))= {
        match state {
            State::Idle$(priority) => {
                match ((*port1.cyc) && (*port1.stb), (*port2.cyc) && (*port2.stb)) {
                    (false, false) => State::Idle(priority),
                    (true, false) => State::Service1(delay1),
                    (false, true) => State::Service2(delay2),
                    (true, true) => if priority == 0 {
                        State::Service1(delay1)
                    }
                    else {
                        State::Service2(delay2)
                    }
                }
            },
            State::Service1(delay) => {
                if delay == 0 {
                    State::Idle(1)
                } else {
                    State::Service1(trunc(delay - 1))
                }
            },
            State::Service2(delay) => {
                if delay == 0 {
                    State::Idle(0)
                } else {
                    State::Service2(trunc(delay - 1))
                }
            }
        }
    };

    let (addr, write) = match state {
        State::Service1(0) => (*port1.addr, *port1.write),
        State::Service2(0) => (*port2.addr, *port2.write),
        _ => (0, None())
    };

    let (we, data) = match write {
        Some(d) => (true, d),
        None => (false, 0)
    };

    let mem: Memory<uint<16>, 16777216> = inst clocked_memory(clk, [(we, addr, data)]);
    let read_value = if we {data} else {inst read_memory(mem, addr)};

    set port1.data_out = read_value;
    set port2.data_out = read_value;

    set port1.ack = match state {
        State::Service1(0) => true,
        _ => false
    };
    set port2.ack = match state {
        State::Service2(0) => true,
        _ => false
    };
    set port1.err = false;
    set port2.err = false;

    true
}

// Increment a number at a specific address until the end of time. Returns
// the number if it was updated this cycle
entity wishbone_pounder(
    clk: clock,
    rst: bool,
    wb: DramWishbone,
    addr: uint<24>
) -> uint<16> {
    let stb = wb.stb;
    let cyc = wb.cyc;
    let ack = *wb.ack;
    reg(clk) last_read reset(rst: 0) = {
        if inst read_mut_wire(stb) && inst read_mut_wire(cyc) && ack {
            *wb.data_out
        }
        else {
            last_read
        }
    };

    set stb = true;
    set cyc = true;
    set wb.addr = addr;
    set wb.sel = 0b11;
    set wb.write = Some(trunc(last_read + 1));

    last_read
}

entity wb_harness(clk: clock, rst: bool) -> (uint<16>, uint<16>) {
    let (wb1, wb1inv) = port;
    let (wb2, wb2inv) = port;

    let _ = inst wishbone_arbiter(clk, rst, wb1inv, wb2inv, 3, 6);

    let o1 = inst wishbone_pounder(clk, rst, wb1, 1);
    let o2 = inst wishbone_pounder(clk, rst, wb2, 2);

    (o1, o2)
}
